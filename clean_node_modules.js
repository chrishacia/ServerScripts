#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const os = require('os');
const cliProgress = require('cli-progress');

// Define a limit to the number of concurrent deletions
const CONCURRENCY_LIMIT = os.cpus().length; // Number of CPU cores

// Helper function to format file sizes
function formatBytes(bytes, decimals = 2) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

// Helper function to get the total size of a folder recursively
async function getFolderSize(folderPath) {
  let totalSize = 0;
  try {
    const files = await fs.promises.readdir(folderPath, { withFileTypes: true });
    for (const file of files) {
      const fullPath = path.join(folderPath, file.name);
      try {
        const stats = await fs.promises.stat(fullPath);
        if (stats.isDirectory()) {
          totalSize += await getFolderSize(fullPath);  // Recursively get size for directories
        } else {
          totalSize += stats.size;  // Add size for files
        }
      } catch (err) {
        if (err.code === 'ENOENT') {
          console.warn(`File or directory not found: ${fullPath}`);
        } else {
          throw err;  // Re-throw if it's a different error
        }
      }
    }
  } catch (err) {
    if (err.code === 'ENOENT') {
      console.warn(`Directory not found: ${folderPath}`);
    } else {
      throw err;  // Re-throw if it's a different error
    }
  }
  return totalSize;
}

// Function to recursively search for node_modules directories
async function findNodeModulesDirs(folderPath, results = []) {
  try {
    const stats = await fs.promises.lstat(folderPath);  // Use lstat to check for symbolic links

    if (stats.isSymbolicLink()) {
      console.warn(`Skipping symbolic link: ${folderPath}`);
      return results;  // Skip symbolic links
    }

    if (!stats.isDirectory()) return results;

    const files = await fs.promises.readdir(folderPath);
    for (const file of files) {
      const currentPath = path.join(folderPath, file);
      try {
        const currentStats = await fs.promises.lstat(currentPath);  // Use lstat for each item
        if (currentStats.isSymbolicLink()) {
          console.warn(`Skipping symbolic link: ${currentPath}`);
          continue;  // Skip symbolic links
        }

        if (currentStats.isDirectory()) {
          if (file === 'node_modules') {
            results.push(currentPath);
          } else {
            await findNodeModulesDirs(currentPath, results);  // Recurse into subdirectories
          }
        }
      } catch (err) {
        if (err.code === 'ENOENT') {
          console.warn(`File or directory not found: ${currentPath}`);
        } else {
          throw err;  // Re-throw if it's a different error
        }
      }
    }
  } catch (err) {
    if (err.code === 'ENOENT') {
      console.warn(`Directory not found: ${folderPath}`);
    } else {
      throw err;  // Re-throw if it's a different error
    }
  }

  return results;
}

// Function to delete the queued node_modules folders and calculate their size
async function deleteQueuedDirs(queue, progressBar, logStream) {
  let totalSize = 0;

  for (let i = 0; i < queue.length; i++) {
    const nodeModulePath = queue[i];

    // Update the progress bar with the folder being deleted
    progressBar.update(i + 1, { folder: nodeModulePath });

    try {
      // Get the size of the folder before deletion
      const folderSize = await getFolderSize(nodeModulePath);
      totalSize += folderSize;

      // Log the folder being deleted
      logStream.write(`${nodeModulePath}\n`);

      // Perform deletion
      await limiter(() =>
        fs.promises.rm(nodeModulePath, { recursive: true, force: true })
      );
    } catch (err) {
      if (err.code === 'ENOENT') {
        console.warn(`Node_modules folder not found or already deleted: ${nodeModulePath}`);
      } else {
        throw err;  // Re-throw if it's a different error
      }
    }
  }

  return totalSize;
}

// Main function to handle the entire process
async function cleanNodeModules(startPath) {
  try {
    console.log(`Starting cleanup from: ${startPath}`);

    // Step 1: Find all node_modules directories
    const queue = await findNodeModulesDirs(startPath);
    if (queue.length === 0) {
      console.log('No node_modules directories found.');
      return;
    }

    // Step 2: Generate log file with timestamp
    const now = new Date();
    const logFileName = `clean_log-${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}.txt`;
    const logStream = fs.createWriteStream(logFileName, { flags: 'a' });
    console.log(`Logging deleted folders to: ${logFileName}`);

    // Step 3: Initialize the progress bar
    const progressBar = new cliProgress.SingleBar(
      {
        format: 'Deleting node_modules |{bar}| {percentage}% | {value}/{total} Folders | Current: {folder}',
        hideCursor: true,
        stopOnComplete: true,
        clearOnComplete: true,
      },
      cliProgress.Presets.shades_classic
    );

    progressBar.start(queue.length, 0, { folder: 'Starting...' });

    // Step 4: Delete all queued node_modules directories and calculate total size
    const totalSize = await deleteQueuedDirs(queue, progressBar, logStream);

    // Step 5: Stop the progress bar and log completion
    progressBar.stop();
    console.log(`Total deleted size: ${formatBytes(totalSize)}`);
    console.log('Cleanup complete.');

    // Close the log stream
    logStream.end();
  } catch (err) {
    console.error('Error during cleanup:', err);
  }
}

// Function to manage concurrent execution
const limiter = (() => {
  let activePromises = 0;
  const queue = [];

  const runNext = () => {
    if (queue.length > 0 && activePromises < CONCURRENCY_LIMIT) {
      activePromises++;
      const { fn, resolve, reject } = queue.shift();
      fn()
        .then(resolve)
        .catch(reject)
        .finally(() => {
          activePromises--;
          runNext();
        });
    }
  };

  return (fn) =>
    new Promise((resolve, reject) => {
      queue.push({ fn, resolve, reject });
      runNext();
    });
})();

// Capture the path argument from the command line
const args = process.argv.slice(2);
if (args.length === 0) {
  console.error('Error: No path provided.');
  console.log('Usage: clean_node_modules.js <path_to_directory>');
  process.exit(1);
}

// Function to expand '~' to the user's home directory
function expandHomeDir(inputPath) {
  if (inputPath.startsWith('~')) {
    return path.join(os.homedir(), inputPath.slice(1));
  }
  return inputPath;
}

const startPath = path.resolve(expandHomeDir(args[0]));

// Ensure the provided path exists
fs.promises
  .access(startPath)
  .then(() => cleanNodeModules(startPath))
  .catch((err) => {
    console.error(`Invalid path provided: ${startPath}`);
    console.error(err.message);
    process.exit(1);
  });
